# Ch 1. Introduce to Database
***
1st wirte : 2019. 01 . 01 ( O )   
2nd write : 2019. 01. 02  
3rd write : 2019. 01. 04  
4th write : 2019. 01. 07  
5th write : 2019. 01. 14  
6th write : 2019. 01. 30  
***

## 1. DEVLOPER로서 요구되는 스킬
좋은소프트 웨어란 무엇인가? 에 대한 논쟁은 끊임 없이 되고 있으나,  이를 평가하는 지표 중 중요한 것은 `매출` 이다.

그러나 `매출`은 기술적인 면 이외의 요소에 크게 의존한다.  

그리고 상용 소프트웨어 뿐만 아니라 세상의 다양한 제품들이 최첨단인지 아닌지는 그 제품의 흥행에 직접적으로 연관되는 것은 아니라, 컨셉에 연관이 되어 있다.

기술자 적인 관점에서는 `제품이 매력적`으로 느낄 수 있도록 `신속하고 확실하게` 구현 하는 것

그렇기에 Develpoer로써 필요한 능력은  

    1. 신속하고 확실한 구현

    2. Solution 또는 web의 수정 및 Update를 고려한 설계 기술

    3. TDD(Test Driven Development)

    4. 소프트웨어 공학(설계 방법 및 개발 프로세스)
        - 설계 방법 : 구조적 프로그래밍, OOP
        - 객체지향 기술

### 그렇다면 DB는 왜 중요할까?
데이터를 필요로 하는 곳에서는 예외 없이 데이터 베이스가 중요하다. 그렇기에 DB에 대한 이해가 필요한데

DB에 대한 이해가 부족하면

    1. 성능 문제 발생
    2. 데이터가 잘못된 상태가 됨(일관성, 정합성이 없음)
    3. 데이터 손실의 문제
    4. 시스템 장애로 인한 큰 손실

### 그런데 왜 DB를 어려워 하고, 잘 알지 못할까?

    1. Database 만으로 동작하는 SW를 만들 수 없음
    2. Non-visible Interaction이 많기 때문에 이를 파악하는게 어려움
***
## 2. 데이터베이스가 필요한 이유?
    1.  대량의 DATA들 중 필요한 것을 빨리 반환할 수 있다
    2.  대량의 DATA를 Main memory와 작업을 하는데 도와준다
    3.  장애시 빠른 복구를 가능하게 해준다.
    4.  병렬성 제어를 편리하게 할 수 있다.
    5.  데이터 무결성을 보장한다.

데이터베이스에 Access해서 작업을 하기 위해선 단지 rw만 하는게 아니라 SQL 작성 처리, 결과 셋의 검색 처리 뿐만 아니라 나름의 프로그래밍 지식이 필요하다. 이는 Database를 더 어렵고, 힘들다고 느끼게 만드는데, 이 지식들이 필요한 이유는

    1.  향후 신기술에 대한 평가 및 사용이유에 대한 정확한 이해 가능
    2.  DB 원리를 알고, 적재적소에 사용하기 위해
        - Data와 Table, 관계에 대한 특징을 고려하지 않을 경우 향후 반드시  문제가 생긴다.

### 1. 대량의 DATA들 중 필요한 것을 빨리 반환할 수 있다.
만약 사용자 수가 천만명이라 가정 할 경우, 사용자의 행동 관련 정보는 수억개에 달하게 되고, 이는 DB에 저장된다.

이런 데이터를 관리한다고 할 때, 사용자 편리성 및 서비스의 진행을 위해 `고속`, `효율적`으로 작업할 수 있어야 하는데, Data의 규모는 `억`단위로 방대하다면 이를 어떻게 처리 할지 고민해 봐야 한다.

만약 `검색`을 하게 될 경우 순차접근으로 한다면 `효율성`과 `속도`라는 측면을 고려했을 때 좋지 않은 선택일 것이다. 이렇게 방대한 데이터를 처리하기 위해서 효율적인 데이터 구조로 관리해야 한다.

그러나 `텍스트파일`이나 `엑셀`에서는 이런 부분을 관리하기 힘들기 때문에 `신속`성에서 데이터베이스를 따라갈 수 없다.
***
### 2.  대량의 Data를 Main memory와 작업을 하는데 도와준다.
Main memory의 사용 가능한 용량과, 휘발성을 고려한다면 `빅데이터`를 다루는데 메모리만을 사용하는 것은 `risky`한 방식이다.

만약 `Java`에 있는 `util lib`인 `HashMap`을 사용한다 하더라도 여기서 사용하는 `Index`는 메모리 내에서만 사용할 수 있기 때문에, 메인 메모리 용량이 커졌다 하더라도 `빅데이터`를 처리하는데는 한계가 존재한다.

이는 대량의 사용자를 취급하는데 어려울 뿐만 아니라

    1. 수많은 사용자들의 엄청난 데이터를 다룰수 없고

    2. 메모리의 휘발성 때문에 시스템 다운시 데이터 소실의 문제가 발생하고

    3.  다운시 복구를 할 때 보조기억장치를 사용한다고 하면 rw시 시간소요가 크다

    4. 만약 메모리로 작업시, 메모리가 대용량 데이터를 처리 할 때, 사용하는 자원이 크고, 고유의 프로세스로 처리를 하다보니, 처리 도중에 생기는 DB CRUD 처리를 
    수행할 수 없다

    5.  망가진 서비스를 복구하는데 오랜 시간이 소요되고, 이는 서비스에서 critical 하게 작용한다.

즉, Memory와 보조기억 장치로만 데이터를 처리하는 것은 무모한 아키텍처 이므로, 디스크를 활용하는 것을 전제로 한 DB 구조가 필요하게 된다.
***
### 3.  장애 발생시 빠른 복구 가능
DB 를 사용하는 핵심 이유로써 성능 향상과 장애 대책 용이가 있다.

SW 결함으로 인한 서버 중단은 Critical하고, 장애에 대한 복구는 상당히 어려운 일이다.

장애 대응의 방법과 수준은 다양하나, 복구 관점에서 핵심 포인트는 `Data의 유실`이다.

Web Server나 Cache Server처럼 자체적으로 Data를 갖지 않은 서버의 경우 Server를 재 실행 하거나 증설해서 서비스를 수행할 수 있으므로 장애의 impact 정도가 Database Server 보다는 낮다.

장애 대응의 방법 중 하나로 `백업`이 존재 하는데 단순한 백업 사용시 문제가 발생하게 되는데

    1.  최종 백업 이후 Update한 결과에 대해 roll-back 할 수 없음
    2. Back-up data를 사용할 때도 시간이 걸리고, 그 기간동안 Down-time이 된다
    3. Back-up 중 update하면 백업이 손상될 위험이 존재한다.

이러한 문제를 해결하기 위해 `Transaction`이란 개념이 도입되는데, 이를 Application logic으로 구현하려면 많은 어려움이 있다. 

그렇기에 DB를 통해 `물경성 관리`를 담당하여 이런 문제를 해결 할 수 있다.

어느정도 규모가 있는 서비스의 경우 동일 데이터가 있는 서버의 `복제(Replication)`을 갖게 하는 구성을 취한다.

결국, DB Server의 경우 `백업`을 하든 `복제`를 하든 그 과정에서 Service를 멈추지 않고 계속 실행해야 하는 것이 중요하다.
***
### 4. 병렬성 제어의 용이
Application 에서 어려운 기술적 포인트가 `배타적 제어`이다

`배타 제어`를 실시하지 않으면 일관성이 무너지게 되고

`배타적 제어`의 범위가 너무 넓으면 병렬성이 떨어지고, 속도 면에서 실용성이 줄어든다

`배타적 제어`에서 이슈가 되는 부분은 `배타의 범위`인데 이를 해결하기 위한 가장 단순한 해결 방법으로는 `Locking`이 존재한다. 그러나 File 단위의 Locking은 비효율적이고, 수많은 Business logic을 해결하지 못하는 단점이 존재한다.

그러나 Database를 사용하면 이런 `배타적제어`문제에 대해 손쉽게 해결 할 수 있다.
***
### 5. 데이터 무결성 보장
데이터 자체의 불일치를 방지. 병렬성 제어와도 연관이 되어 있는 부분으로,

Data Value를 저장 할 때, 명명 척도나 서열 척도로 구성된 변수들의 값을 유지하고, 특정하게 증감시키는 연산이 필요하나, 병렬적 제어시 Issue가 발생하여 이런 데이터의 일관성이 훼손될 수 있다.

그렇기에 데이터 무결성을 보호해야 할 필요성이 있는데, Database에서 참조 무결성 등 다양한 기능으로 이를 해결 할 수 있다.