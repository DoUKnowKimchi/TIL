# 1_02 컴퓨터 시스템의 동작

컴퓨터 시스템으로 작업을 처리할 때 동작 순서는

    1. 입력장치로 정보를 입력받아 메모리에 저장
    2. 메모리에 저장한 정보를 프로그램 제어에 따라 인출하여 연산장치에서 처리
    3. 처리한 정보를 출력장치에 표시하거나 보조기억장치에 저장

    ** 제어장치가 이 동작을 제어함

입력장치로 컴퓨터에 유입되는 정보는 `명령어`와 `데이터`로 분류한다.   

`명령어` : 실행할 산술, 논리 연산의 동작을 명시하는 문장.   

`프로그램` : 어떤 작업을 수행하는 명령어 집합

## 1. 명령어의 구조
명령어 : `연산 부호`(프로세서가 실행할 연산) + `데이터`(명령어가 처리 할) + `피연산자`(데이터를 저장한 레지스터나 메모리 주소인  피연산자)로 구분된다

명령어는 프로세서에 따라 `고정 길이`나 `가변 길이`를 구성한다. `연산 부호`는 특별한 경우가 아니면 한개이나, `피연산자`는 여러 개 일 수 있다.

![명령어의구조](https://slidesplayer.org/slide/11328151/61/images/21/%EB%AA%85%EB%A0%B9%EC%96%B4+%ED%98%95%EC%8B%9D+%282%29+%28a%29+3-%EC%98%A4%ED%8D%BC%EB%9E%9C%EB%93%9C+%28b%29+2-%EC%98%A4%ED%8D%BC%EB%9E%9C%EB%93%9C+%28c%29+1-%EC%98%A4%ED%8D%BC%EB%9E%9C%EB%93%9C+%28d%29+0-%EC%98%A4%ED%8D%BC%EB%9E%9C%EB%93%9C.jpg)

    연산부호(OPeration code / OPcode) : 프로세서가 실행할 연산을 지정한다.
    산술 연산(+-/*), 논리 연산(AND, OR, NOT), 시프트, 보수 등 연산을 정의 한다.
    연산부호가 n비트이면 최대 2^n 개 연산 가능

    피연산자(operand) : 연산할 데이터 정보를 저장한다. 
    데이터는 레지스터나 메모리, 가상기억장치, 입출력장치 등에 위치할 수 있다. 데이터 자체보다 데이터의 위치를 저장한다.

    명령어는 실행 전에 메인 메모리에 저장하며, 한 번에 하나씩 프로세서에 순차적으로 전송하여 해석, 실행한다.

    연산 부호 / 피연산자1 / 피연산자2
    Y = X + B
    목적지 피연산자 = 소스 피연산자 + 연산 부호 + 소스 피연산자

    ** 누산기 : 메모리에서 읽은 피연산자를 레지스터에 저장된 데이터와 연산할 때 사용하는 프로세서의 레지스터.
    누산기는 프로그램의 명령어 수행 중에 산술, 논리 연산의 결과를 일시적으로 저장함.

모드 비트(mode bit) : 명령어에 피연산자의 위치를 명시하는 방법(직접 주소 또는 간접주소)을 나타내는 것  
0 / 0000 / 000000
I / 연산부호 / 피연산자
모드가 0 이면 직접주소, 1이면 간접주소(K V, Hash 처럼 생각하면 될 듯!)

`직접 주소(direct address)`: 피연산자에 레지스터나 메모리 주소를 지정  
`간접 주소` : 레지스터나 메모리 주소 정보를 지정. 데이터의 주소 읽을 때 한 번, 데이터를 읽을 때 한 번, 총 두 번 메모리 참조한다.
***

## 2. 명령어의 실행
    1. 명령어 인출 
        명령어 레지스터에 저장된 다음 명령어 인출
    2. 명령어 해석, 프로그램 카운터 변경 
        인출한 명령어 해석, 다음 명령어 지정하려고 프로그램 카운터 변경
    3. 피연산자 인출 
        명령어가 메모리에 있는 워드를 한 개 사용하려면 사용 장소를 결정하여 피연산자를 인출하고, 필요하면 
        프로세서 레지스터로 보낸다.
    4. 명령어 실행
    5. 결과 저장
    6. 다음 명령어로 이동

    프로세서 제어장치가 명령어 실행 => 프로세서는 메모리에서 명령어를 한 번에 하나씩 인출, 해석 => 명령어 인출하여 연산 완료한 시점까지를 인출-해석-실행 사이클 (인출 - 실행 사이클 / 명령어 실행 주기) 라고 한다.
    인출 - 실행의 반복에서 인터럽트 발생 및 간접 사이클(실제 주소를 기억 장치에서 읽어 오는)

### 2-1 인출 사이클(Fetch cycle)
메모리에서 명령어를 읽어 `명령어 레지스터`에 저장 => 명령어 실행하려고 `프로그램 카운터 증가 ` 
명령어 인출 시간 : 인출 사이클에 소요되는 시간
    
    1. PC -> MAR : PC에 저장된 주소를 프로세서 내부 버스를 이용해 MAR에 전달
    2. MAR -> MBR : MAR에 저장된 주소에 해당되는 메모리 위치에서 명령어를 인출 후 이 명령어를 MBR에 저장. 
       이때 제어장치는 메모리에 저장된 내용을 읽도록 제어 신호 발생.
       PC + 1 -> PC : 다음 명령어를 인출하려고 PC 증가
    3. MBR -> IR : MBR에 저장된 내용을 IR(명령어 레지스터)에 전달
***
### 2-2 실행 사이클(Execution cycle)
인출한 명령어를 해독하고 결과에 따라 제어 신호를 발생시켜 명령어 실행.  
실행 시간 : 이 단계에서 소비되는 시간
***
### 2-3 간접 사이클(Indirect cycle)
DA(Direct Addressing)을 사용하는 실행 사이클은 명령어 즉시 실행  
IA(Indriect Addresssing)을 사용하는 실행 사이클은 명령어 수행 전 실제 데이터가 저장된 주 기억장치의 주소를 한번 더 읽어 온다.

    1. IR -> MAR : IR에 저장된 명령어의 operand를 MAR에 전달
    2. MAR -> MBR : MAR에 저장된 주소에 해당하는 메모리 위치에서 데이터를 인출한 후 데이터를 MBR에 저장
       제어장치는 메모리에 저장된 내용을 읽도록 제어 신호 발생
    3. MBR -> IR : MBR에 저장된 내용을 IR에 전달
***
### 2-4 인터럽트 사이클(Interupt cycle)
`인터럽트` : 프로세서가 프로그램을 수행하는 동안 컴퓨터 시스템의 내부나 외부에서 발생하는 예기치 못한 사건  
프로세서는 실행 사이클 완료 후 인터럽트 요구가 있는지 검사.  

요구가 없으면 다음 명령어 인출,  

요구가 있으면 현재 수행 중인 프로그램의 주소(프로그램 카운터) 값을 스택이나 메모리의 특정 장소에 저장.  

프로그램 카운터에는 인터럽트 처리 루틴의 시작 주소를 저장해 두었다가 인터럽트 처리 완료 후 중단된 프로그램으로 복귀하여 계속 수행

    1. PC -> MBR : PC의 내용을 MBR에 전달
    2. IntRountine_Address -> PC : 인터럽트 루틴 주소를 PC에 전달
        Save_Address -> MAR : PC에 저장된 인터럽트 루틴 주소를 MAR에 저장
    3. MBR -> MAR : MBR 주소에 있는 내용을 지시된 메모리 셀로 이동
***
## 3 인터럽트 명령어
`인터럽트` : 현재 실행 중인 프로그램을 중단하고 다른 프로그램의 실행을 요구하는 명령어  
시스템의 처리 효율을 향상시키며, 프로그램이 실행 순서를 바꿔 가면서 처리하여 다중 프로그래밍에 사용

컴퓨터에 설치된 `입출력장치`나 `프로그램` 등에서 `프로세서`로 보내는 `하드웨어 신호`

프로세서의 컴퓨터는 명령어를 한 번에 한 개만 수행하나 `인터럽트를 이용하면 중간에 다른 프로그램이나 명령어를 수행할 수 있다. `

인터럽트는 프로그램의 정상 실행을 일시 중단했다 다시 재개하는 과정, 사용자가 별도 조치 할 필요 없이 프로세서와 운영체제가 처리함

ex) 예상치 못한 사용자 입력, 갑작스런 정전, 컴퓨터 시스템에서 긴급 요청, 잘못된 명령어 수행, 입출력 작업 완료등을 적절히 처리할 때 필요 하다.

    컵퓨터는 인터럽트를 외부장치의 동작과 자신의 동작을 조정하는 수단으로 사용.
    프로세서는 각 입출력장치의 현재 상태를 파악하고 있어야 하는데, 이 상태를 나타내려면 1비트 이상으로 표현한 준비비트 또는 상태비트가 필요하다.

    입출력 장치가 새로운 연산을 수행하려고 하면 프로세서는 `폴링`으로 각 장치의 상태비트를 검사한다. 인터럽트 개념이 없으면 장치의 상태를 계속 검사해야 하므로 프로세서가 다른 연산을 수행 할 수 없으므로 오버헤드가 증가하여 수행 시간이 낭비된다.
    
    이 때 인터럽트를 사용하면 입출력장치가 준비 상태가 될 때까지 프로세서가 다른 작업을 수행할 수 있다. 즉, 입출력장치가 준비 상태가 되었을 때 프로세서에 인터럽트 신호를 보내면 된다.

    제어 버스 중 이런 목적으로 사용하는 것이 인터럽트 회신 요청(IRQ : Interupt Request line)

    이를 사용하면 키보드에서 입력이 발생했을 때만 프로세서에 통보하여 처리하므로 프로세서가 이벤트 발생 여부를 일일이 감시하지 않아도 된다.

    프로세서가 외부장치의 상태를 직접 점검할 필요가 없어 이 시간 동안 다른 연산을 수행하여 프로세서의 효율을 높일 수 있다.

    인터럽트는 인터럽트 요청과 인터럽트 서비스 루틴으로 구분 할 수 있다.
    인터럽트 서비스 루틴 : 인터럽트 요청 신호에 따라 수행하는 루틴.

    인터럽트 요청 회선(IRQ는) 단일 회선과 다중 회선으로 연결할 수 있다.

     단일 회선 : 인터럽트 요청이 가능한 모든 장치를 공통의 단일 회선으로 프로세서에 연결하는 방법. 인터럽트 요청한 장치를 판별하는 기능이 필요하다.

     다중 회선 : 모든 장치를 서로 다른 고유의 회선으로 연결하는 방법. 바로 요청한 장치 판별 가능

    IRS(Interupt Request Signal)이 발생하면 대부분 컴퓨터는 정보를 단일 명령어로 저장할 수 있으므로 실행 중인 프로그램을 메모리에 저장하고 인터럽트 처리 프로그램으로 분기한다. 그리고 인터럽트 처리 프로그램을 완료하면 인터럽트를 발생시킨 프로그램에 제어를 돌려준다.

인터럽트는 서브루틴 호출과 비슷하나 다른 면이 존재한다.
    1. 서브루틴은 자신을 호출한 프로그램이 요구한 기능을 수행하나 인터럽트 처리 프로그램은 인터럽트가 발생했을 때 실행 중인 프로그램과 관련이 없을 수도 있다.

    그렇기에 프로세서는 인터럽트 프로그램을 처리하기 전에 프로그램 카운터를 비롯해 중단된 프로그램으로 복귀하여 실행할 때 영향을 미치는 정보를 저장해야 한다.
    인터럽트가 발생했을 때 상태 코드(상태 워드)를 임시 기억장치에 저장해 두었다가 나중에 복귀했을 때 이를 적재해야 한다. 그래야 원래 프로그램을 인터럽트의 영향을 받지 않고 다시 실행할 수 있음.